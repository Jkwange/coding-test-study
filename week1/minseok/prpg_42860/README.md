# coding-test-study
카테고리는 그리디이지만, 그때그때 최적의 해를 찾아가는 방식으로는 어떻게 푸는지 몰라서 그냥 반복문으로 전체를 순회하면서 정보를 얻어서 풀었다.

일단 모든 자리의 알파벳은 'A'로 고정이라서, 상하로 움직이는 조이스틱은 무조건 값이 정해져있다. 
먼저 answer 변수에 각 자라의 알파벳 변위 값을 모두 저장한다. 이때 주의할 점은 'A'를 0번째 알파벳이라고 가정했을때, 중간 위치인 13번째 알파벳을 기준으로 'A'에서 조이스틱을 위로 이동하는 게 최단 거리인지, 아래로 이동하는 게 최단 거리인지가 정해진다.
 
 이 문제의 관건은 좌우이동이다. 상하이동은 고정값이기 때문에, 좌우이동에서 이동 수를 줄여야한다. 내가 생각한 최적의 방법은, 알파벳이 이미 'A'인 자리는 굳이 접근하지 않아도 되기 때문에, 가급적이면 연속된 'A'는 피하는 것이다. 그렇게 하기 위해서는 문자열을 순회하면서 연속된 'A'가 가장 긴 길이와, 그때의 문자열 상 마지막 인덱스를 저장해놓아야한다고 생각했다. 
 좌우이동을 나타내는 변수 move의 초기 값은 기본적인 순회를 뜻하는 (문자열의 길이 -1)로 하였다. 여기까지는 쉽게 접근했는데, 그 뒤에 연속된 'A'를 피하는 최적의 해를 구하는 과정을 알고리즘으로 표현하는 게 시간이 오래걸렸다. 그러다가 케이스를 두개로 나누어서, 오른쪽으로 이동하다가 왼쪽으로 다시 틀어서 쭉 가는 경우, 왼쪽으로 이동하다가 오른쪽으로 다시 틀어서 쭉 가는 경우 이렇게 두가지 케이스로 나누어서 최솟값을 구해서 move를 구하는 것을 생각해냈다. 

 # 난관
 위의 방법으로 채점을 했는데, 일부 테스트케이스가 틀렸길래 원인을 찾다가 '질문하기'에 올라온 글을 통해서 힌트를 얻었다. 첫번째 위치에서 왼쪽으로 이동하면 제일 뒷 위치로 이동하는 성질을 간과하고 있었다. 만약 문자열의 앞쪽과 문자열의 제일 뒷쪽이 연속된 'A'로 이어져 있으면 문자열상으로는 제일 긴 연속된 'A'가 아닐 수 있지만 이 문제의 성질을 고려하면 제일 긴 연속된 'A'가 될 수 있다. 그래서 if문으로, 문자열의 0번째 위치가 'A'인 경우에는 문자열 앞쪽의 연속된 'A'와 문자열 뒷쪽의 연속된 'A'를 구해서 문제를 풀었다. 

